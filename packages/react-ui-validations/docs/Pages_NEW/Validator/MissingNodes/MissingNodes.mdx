import { Meta, Canvas } from '@storybook/blocks';
import * as DocsStories from './MissingNodes.docs.stories.tsx';

<Meta of={DocsStories} />

# Отсутствующие узлы

## Узел отсутствует в модели

Валидируемый объект может содержать вложенные объекты.
Если в узле лежит `null` вместо объекта, то значения его детей неопределены.
В таком случае правило конфигурирования детей не будет к ним применено.
Писать дополнительных проверок не требуется.
Добавить правила валидации на узел, в котором лежит `null` - можно.

```jsx static
    interface ContactInfo {
      name: string;
    }

    interface Data {
      contact: ContactInfo | null;
    }

    const validate = createValidator<Data>(b => {
      b.prop(x => x.contact, b => {
        b.prop(x => x.name, b => {
          //...
        });
      });
    });

    const data: Data = {contact: null};
    const validation = validate(data);
    const validationInfo = validation.getNode(x => x.contact.name).get();
    // -> null
```

В данном примере узел `contact` имеет значение `null`, то есть он не является объектом.
Значит поля описанные в типе `ContactInfo` не определены.
Поэтому функция конфигурирования узла `name` не выполнится.

### Пример

<Canvas of={DocsStories.MissingObjectNode} />

```jsx static
import React from 'react';
import { Button } from '@skbkontur/react-ui/components/Button';
import { Input } from '@skbkontur/react-ui/components/Input';
import { Toggle } from '@skbkontur/react-ui/components/Toggle';

import { ValidationContainer, ValidationWrapper, createValidator } from '../../../../src';
import { Nullable } from '../../../../typings/Types';
import { Form } from '../../../Common/Form';

interface ContactInfo {
  name: string;
  email: string;
}

interface Data {
  contact: Nullable<ContactInfo>;
}

const validate = createValidator<Data>((b) => {
  b.prop(
    (x) => x.contact,
    (b) => {
      b.prop(
        (x) => x.name,
        (b) => {
          b.invalid((x) => !x, 'Укажите имя', 'submit');
        },
      );
      b.prop(
        (x) => x.email,
        (b) => {
          b.invalid((x) => !x, 'Укажите email', 'submit');
          b.invalid((x) => !x.includes('@'), 'Неверный формат email');
        },
      );
    },
  );
});

interface MissingObjectNodeDemoState {
  data: Data;
}
export default class MissingObjectNodeDemo extends React.Component {
  public state: MissingObjectNodeDemoState = {
    data: {
      contact: null,
    },
  };

  private container: Nullable<ValidationContainer> = null;

  public render() {
    const { data } = this.state;
    const v = validate(data).getNode((x) => x.contact);
    return (
      <ValidationContainer ref={this.refContainer}>
        <Form>
          <Form.Line title="Валидации">JSON</Form.Line>

          <Form.Line title="Имя">
            {JSON.stringify(v.getNode((x) => x.name).get())}
          </Form.Line>

          <Form.Line title="E-mail">
            {JSON.stringify(v.getNode((x) => x.email).get())}
          </Form.Line>

          <Form.LineBreak />

          <Form.Line title="Указать контакты">
            <Toggle
              checked={!!data.contact}
              onValueChange={(checked) =>
                this.handleChange({ contact: checked ? { name: '', email: '' } : null })
              }
            />
          </Form.Line>

          {data.contact && (
            <>
              <Form.Line title="Имя">
                <ValidationWrapper validationInfo={v.getNode((x) => x.name).get()}>
                  <Input
                    placeholder={'Любое'}
                    value={data.contact.name}
                    onValueChange={(name) => this.handleContactChange({ name })}
                  />
                </ValidationWrapper>
              </Form.Line>

              <Form.Line title="E-mail">
                <ValidationWrapper validationInfo={v.getNode((x) => x.email).get()}>
                  <Input
                    placeholder={'xxx@xxx.xx'}
                    value={data.contact.email}
                    onValueChange={(email) => this.handleContactChange({ email })}
                  />
                </ValidationWrapper>
              </Form.Line>
            </>
          )}

          <Form.ActionsBar>
            <Button use={'primary'} onClick={this.handleSubmit}>
              Submit
            </Button>
          </Form.ActionsBar>
        </Form>
      </ValidationContainer>
    );
  }

  private handleContactChange = (value: Partial<ContactInfo>): void => {
    const contact = this.state.data.contact;
    if (!contact) {
      throw new Error('invalid state');
    }
    this.handleChange({ contact: { ...contact, ...value } });
  };

  private handleChange = (value: Partial<Data>): void => {
    this.setState({ data: { ...this.state.data, ...value } });
  };

  private handleSubmit = async (): Promise<void> => {
    if (!this.container) {
      throw new Error('invalid state');
    }
    if (await this.container.validate()) {
      alert('success');
    }
  };

  private refContainer = (el: Nullable<ValidationContainer>) => (this.container = el);
}
```

## Узел не отображается на UI

Валидация формы методом `ValidationContainer.validate()` происходит только по отрисованным компонентам `ValidationWrapper`.

Если где-то определен объект `validationInfo`, но он не передан ни в один из отрисованных компонентов `ValidationWrapper`, то он никак не влияет на результат валидации формы с помощью метода `ValidationContainer.validate()`.

Это означает, что в правилах валидации можно не дублировать условия, при которых поле отображается в интерфейсе, и всегда валидировать его узел в модели.

В примере ниже валидация на поля _Имя_ и _E-mail_ вычисляется всегда, но когда поля отсутствуют, форма будет валидной.

### Пример

<Canvas of={DocsStories.MissingUiNode} />

```jsx static
import React from 'react';
import { Button } from '@skbkontur/react-ui/components/Button';
import { Input } from '@skbkontur/react-ui/components/Input';
import { Toggle } from '@skbkontur/react-ui/components/Toggle';

import { ValidationContainer, ValidationWrapper, createValidator } from '../../../../src';
import { Nullable } from '../../../../typings/Types';
import { Form } from '../../../Common/Form';

interface ContactInfo {
  name: string;
  email: string;
}

interface Data {
  withContact: boolean;
  contact: ContactInfo;
}

const validate = createValidator<Data>((b) => {
  b.prop(
    (x) => x.contact,
    (b) => {
      b.prop(
        (x) => x.name,
        (b) => {
          b.invalid((x) => !x, 'Укажите имя', 'submit');
        },
      );
      b.prop(
        (x) => x.email,
        (b) => {
          b.invalid((x) => !x, 'Укажите email', 'submit');
          b.invalid((x) => !x.includes('@'), 'Неверный формат email');
        },
      );
    },
  );
});

interface MissingObjectNodeState {
  data: Data;
}
export default class MissingObjectNode extends React.Component {
  public state: MissingObjectNodeState = {
    data: {
      withContact: false,
      contact: {
        name: '',
        email: '',
      },
    },
  };

  private container: Nullable<ValidationContainer> = null;

  public render() {
    const { data } = this.state;
    const v = validate(data).getNode((x) => x.contact);
    return (
      <ValidationContainer ref={this.refContainer}>
        <Form>
          <Form.Line title="Валидации">JSON</Form.Line>

          <Form.Line title="Имя">
            {JSON.stringify(v.getNode((x) => x.name).get())}
          </Form.Line>

          <Form.Line title="E-mail">
            {JSON.stringify(v.getNode((x) => x.email).get())}
          </Form.Line>

          <Form.LineBreak />

          <Form.Line title="Указать контакты">
            <Toggle
              checked={data.withContact}
              onValueChange={(withContact) => this.handleChange({ withContact })}
            />
          </Form.Line>

          {data.withContact && (
            <>
              <Form.Line title="Имя">
                <ValidationWrapper validationInfo={v.getNode((x) => x.name).get()}>
                  <Input
                    placeholder={'Любое'}
                    value={data.contact.name}
                    onValueChange={(name) => this.handleContactChange({ name })}
                  />
                </ValidationWrapper>
              </Form.Line>

              <Form.Line title="E-mail">
                <ValidationWrapper validationInfo={v.getNode((x) => x.email).get()}>
                  <Input
                    placeholder={'xxx@xxx.xx'}
                    value={data.contact.email}
                    onValueChange={(email) => this.handleContactChange({ email })}
                  />
                </ValidationWrapper>
              </Form.Line>
            </>
          )}

          <Form.ActionsBar>
            <Button use={'primary'} onClick={this.handleSubmit}>
              Submit
            </Button>
          </Form.ActionsBar>
        </Form>
      </ValidationContainer>
    );
  }

  private handleContactChange = (value: Partial<ContactInfo>): void => {
    this.handleChange({ contact: { ...this.state.data.contact, ...value } });
  };

  private handleChange = (value: Partial<Data>): void => {
    this.setState({ data: { ...this.state.data, ...value } });
  };

  private handleSubmit = async (): Promise<void> => {
    if (!this.container) {
      throw new Error('invalid state');
    }
    if (await this.container.validate()) {
      alert('success');
    }
  };

  private refContainer = (el: Nullable<ValidationContainer>) => (this.container = el);
}
```
